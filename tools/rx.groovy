import groovy.io.FileType

import java.util.regex.Matcher

// Incoming script parameters:
// serviceDir - directory with wsimport generated Java source files. Can start with /
//              and then it is absolute path, or without / - then it is subdirectory of current gradle project.
// rxFileDir - directory into which file with RX wrappers will be generated. Can start with /
//             and then it is absolute path, or without / - then it is subdirectory of current gradle project.
// rxFileName - RX wrappers will be generated into file of this name.
// rxFilePackageName - name of package that will be put into generated RX wrappers files.

println "Executing rx.groovy script with Groovy version: ${GroovySystem.version}"

//
// Main script steps
//
(baseServiceDirectory, serviceFilePath) = figureOutWebServiceDirectoryAndFileDetails()

(servicePackageName, serviceClassName, portClassName, getPortMethodName) = extractWebServiceDetails(serviceFilePath)

portFileBareContent = extractBareContentFromPortFile(baseServiceDirectory, portClassName)

publicMethodNamesParamsAndReturns = extractPublicMethodNamesParamsAndReturns(portFileBareContent)

rxMethods = wrapMethodsWithRxCall(portClassName, publicMethodNamesParamsAndReturns)

backendFilePath = generateRxServiceFile(rxMethods, servicePackageName, portClassName, getPortMethodName)

println "Successfully generated RX service file: ${backendFilePath}"

//
// Helper methods
//

// This function will take script's incoming parameter serviceDir and normalize it to full path
// with trailing separator. Then it will find Java file with Web Service.
// Returns list of 2 values: full path to directory with code generated by wsimport and full path to file
// that contains Web Service.
List<String> figureOutWebServiceDirectoryAndFileDetails() {
    baseServiceDirectory = figureOutBaseWebServiceDirectory()
    println "Directory ${baseServiceDirectory} will be used when searching for generated Web Service files."
    serviceFileName = figureOutServiceFileName(baseServiceDirectory)
    println "Found Web Service in ${serviceFileName} file."
    serviceFilePath = baseServiceDirectory + serviceFileName
    [baseServiceDirectory, serviceFilePath]
}

String figureOutBaseWebServiceDirectory() {
    makeFullPathWithTrailingSeparator(serviceDir)
}

// Tries to find Java file with Web Service generated by wsimport.
// Such file has a class that extends Service.
String figureOutServiceFileName(String serviceDirPath) {
    sDir = new File(serviceDirPath)
    foundServiceFile = ""
    sDir.eachFileRecurse(FileType.FILES) { file ->
        if (file.text.contains("extends Service")) {
            foundServiceFile = file.name
            return
        }
    }
    if (foundServiceFile.isEmpty()) {
        throw new RuntimeException("Unable to find any file that is a WebService in ${serviceDirPath} directory.")
    }
    foundServiceFile
}

// Loads contents of file with service generated by wsimport and extracts:
// - package name
// - service class name
// - service port class name (real web service methods are in port class)
// - which method from service is used to obtain port instance
// All of these will be needed to create file with Observable/Completable wrappers.
List<String> extractWebServiceDetails(String serviceFilePath) {
    println "Loading WebService file: ${serviceFilePath}"
    String serviceFileContents = new File(serviceFilePath).text

    servicePackageName = (serviceFileContents =~ /package ([\w.]+);/)[0][1]
    println "Found service package named ${servicePackageName}"

    serviceClassName = (serviceFileContents =~ /public class (\w+)/)[0][1]
    println "Found service class named ${serviceClassName}"

    portClassName = (serviceFileContents =~ /(\w+)\.class/)[0][1]
    println "Found service port named ${portClassName}"

    getPortMethodName = (serviceFileContents =~ /public \w+ (get\w+)\(/)[0][1]
    println "Found get port method named ${getPortMethodName}"

    [servicePackageName, serviceClassName, portClassName, getPortMethodName]
}

// Loads contents from WS Port class and strips it from unnecessary noise.
String extractBareContentFromPortFile(baseServiceDirectory, portClassName) {
    portFilePath = baseServiceDirectory + portClassName + ".java"
    println "Applying RX Java goodness on file: ${portFilePath}"
    portFileContents = new File(portFilePath).text

    // remove annotations, comments, empty lines. Not strictly necessary but helpful
    // for any future manipulations and extractions
    annotationRegex = /(?s)@\w+\((.*?)\)/
    commentsRegex = /(?m)^(.*?)\*(.*?)$/
    emptyLinesRegex = /(?m)^(?:[\t ]*(?:\r?\n|\r))+/
    portFileContentsStripped = portFileContents.
            replaceAll(annotationRegex, "").
            replaceAll(commentsRegex, "").
            replaceAll(emptyLinesRegex, "")
    portFileContentsStripped
}

Matcher extractPublicMethodNamesParamsAndReturns(String portFileBareContent) {
    (portFileBareContent =~ /(?s)(?:\r?\n|\r)\s+public (.*?) (.*?)\((.*?)\);/)
}

// Given extracted original service methods with return and parameters, wraps them
// into new methods of Observable<T> or Completable type.
// If original method returns void return type - we need to return Completable, for non void Observable<OriginalReturn>.
// Rx Java 2.0 does not allow to return null.
String wrapMethodsWithRxCall(String portClassName, Matcher publicMethodNamesParamsAndReturns) {
    def rxMethodTemplateString = '''\
    public ${rxReturnType} ${rxMethodName}(${parameters}) {
        return ${rxWrapperCall}(() -> ${serviceMethodCall}(${originalParameters}));
    }
'''
    def rxMethodTemplate = new groovy.text.StreamingTemplateEngine().createTemplate(rxMethodTemplateString)

    rxMethods = StringBuilder.newInstance()
    for (i in 0..<publicMethodNamesParamsAndReturns.count) {
        returnType = publicMethodNamesParamsAndReturns[i][1]
        methodName = publicMethodNamesParamsAndReturns[i][2]
        parameters = publicMethodNamesParamsAndReturns[i][3]
        def binding = [
                rxReturnType      : makeRxReturnType(returnType),
                rxWrapperCall     : makeRxWrapperCall(returnType),
                rxMethodName      : methodName,
                parameters        : parameters,
                serviceMethodCall : portClassName.uncapitalize() + "." + methodName,
                originalParameters: paramsExtractor(parameters)
        ]
        rxMethods << rxMethodTemplate.make(binding)
        if (i < publicMethodNamesParamsAndReturns.count - 1) {
            rxMethods << newLineSeparator()
        }
    }
    rxMethods.toString()
}

String makeRxReturnType(type) {
    type == "void" ?
            "Completable" :
            "Observable<${validGenericsType(type)}>"
}

String makeRxWrapperCall(type) {
    type == "void" ?
            "Completable.fromRunnable" :
            "Observable.fromCallable"
}

String validGenericsType(type) {
    if (type == "int") {
        return "Integer"
    }
    if (type == "long") {
        return "Long"
    }
    if (type == "float") {
        return "Float"
    }
    if (type == "double") {
        return "Double"
    }
    if (type == "boolean") {
        return "Boolean"
    }
    if (type.startsWith('Vector')) {
        domainTypeName = type.replaceFirst('Vector', '')
        return domainTypeName.replaceFirst(domainTypeName[0], domainTypeName[0].toUpperCase()) + 'List'
    }
    return type
}

// Takes multiline String with extracted original Service method parameter types and names.
// Extracts only names and forms a line where they are separated by ,
String paramsExtractor(String paramTypesAndNames) {
    paramNames = (paramTypesAndNames =~ /(?m) ([a-z_]\w+),?$/)
    paramsLine = StringBuilder.newInstance()
    paramsLine.with {
        for (i in 0..<paramNames.count) {
            append "${paramNames[i][1]}"
            if (i < paramNames.count - 1) {
                append ", "
            }
        }
    }
    return paramsLine.toString()
}

// This method has all data required to build complete Java source file with RX service wrapper methods
// that do proxy calls to original service instance.
String generateRxServiceFile(String rxMethods, String servicePackageName, String portClassName,
                             String getPortMethodName) {

    def rxFileTemplateString = '''\
package ${rxFilePackageName};

import ${servicePackageName}.*;
import io.reactivex.Observable;
import io.reactivex.Completable;
import java.util.List;


public class ${rxServiceClassName} {
    private ${portClassName} ${portClassName.uncapitalize()};
    
    public ${rxServiceClassName}() {
        ${serviceClassName} service = new ${serviceClassName}();
        ${portClassName.uncapitalize()} = service.${getPortMethodName}();
    }
    
${rxMethods}
}
'''
    def rxFileTemplate = new groovy.text.StreamingTemplateEngine().createTemplate(rxFileTemplateString)

    def binding = [
            rxFilePackageName : rxFilePackageName,
            servicePackageName: servicePackageName,
            rxServiceClassName: rxServiceClassName(),
            portClassName     : portClassName,
            serviceClassName  : serviceClassName,
            getPortMethodName : getPortMethodName,
            rxMethods         : rxMethods
    ]
    backendFile = StringBuilder.newInstance()
    backendFile << rxFileTemplate.make(binding)
    if (!rxFileDir.endsWith("/")) {
        rxFileDir = rxFileDir + "/"
    }
    String backendFilePath = new File(figureOutRxFileDirectory() + rxFileName)
    File backend = new File(backendFilePath)
    backend.text = backendFile.toString()
    backendFilePath
}

String rxServiceClassName() {
    rxFileName.replace(".java", "")
}

String figureOutRxFileDirectory() {
    makeFullPathWithTrailingSeparator(rxFileDir)
}

String currentDir() {
    System.getProperty("user.dir")
}

String newLineSeparator() {
    return System.getProperty("line.separator")
}

String makeFullPathWithTrailingSeparator(String dir) {
    if (!dir.endsWith("/")) {
        dir = dir + "/"
    }
    if (dir.startsWith("/")) {
        return dir
    }
    currentDir() + "/" + dir
}
